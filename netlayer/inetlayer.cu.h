#ifndef I_NET_LAYER_H
#define I_NET_LAYER_H

//****************************************************************************************************
//\file Интерфейс к слою нейросети
//****************************************************************************************************

//****************************************************************************************************
//подключаемые библиотеки
//****************************************************************************************************
#include <stdio.h>

//****************************************************************************************************
//макроопределения
//****************************************************************************************************

//****************************************************************************************************
//константы
//****************************************************************************************************

//****************************************************************************************************
//предварительные объявления
//****************************************************************************************************
template<class type_t>
class CTensor;

class IDataStream;

//****************************************************************************************************
//!Интерфейс к слою нейросети
//****************************************************************************************************
template<class type_t>
class INetLayer
{
 public:
  //-перечисления---------------------------------------------------------------------------------------
  //!режимы обучения
  enum TRAINING_MODE
  {
   TRAINING_MODE_GRADIENT,///<градиентный спуск
   TRAINING_MODE_ADAM///<обучение по алгоритму Adam
  };
  //-структуры------------------------------------------------------------------------------------------
  //-константы------------------------------------------------------------------------------------------
 private:
  //-переменные-----------------------------------------------------------------------------------------
  TRAINING_MODE TrainingMode;///<режим обучения
 public:
  //-конструктор----------------------------------------------------------------------------------------
  INetLayer(void)
  {
   TrainingMode=TRAINING_MODE_GRADIENT;
  };
  //-деструктор-----------------------------------------------------------------------------------------
  virtual ~INetLayer() {};
 public:
  //-открытые функции-----------------------------------------------------------------------------------
  virtual void Reset(void)=0;///<выполнить инициализацию весов и сдвигов
  virtual void SetOutput(size_t unit_index,CTensor<type_t> &output)=0;///<задать выход слоя
  virtual void GetOutput(size_t unit_index,CTensor<type_t> &output)=0;///<получить выход слоя
  virtual void Forward(void)=0;///<выполнить прямой проход по слою
  virtual CTensor<type_t>& GetOutputTensor(size_t unit_index)=0;///<получить ссылку на выходной тензор
  virtual void SetNextLayerPtr(INetLayer<type_t> *next_layer_ptr)=0;///<задать указатель на последующий слой
  virtual bool Save(IDataStream *iDataStream_Ptr)=0;///<сохранить параметры слоя
  virtual bool Load(IDataStream *iDataStream_Ptr)=0;///<загрузить параметры слоя
  virtual bool SaveTrainingParam(IDataStream *iDataStream_Ptr)=0;///<сохранить параметры обучения слоя
  virtual bool LoadTrainingParam(IDataStream *iDataStream_Ptr)=0;///<загрузить параметры обучения слоя
  virtual void TrainingStart(void)=0;///<начать процесс обучения
  virtual void TrainingStop(void)=0;///<завершить процесс обучения
  virtual void TrainingBackward(bool create_delta_weight=true)=0;///<выполнить обратный проход по сети для обучения
  virtual void TrainingResetDeltaWeight(void)=0;///<сбросить поправки к весам
  virtual void TrainingUpdateWeight(double speed,double iteration)=0;///<выполнить обновления весов
  virtual CTensor<type_t>& GetDeltaTensor(size_t unit_index)=0;///<получить ссылку на тензор дельты слоя
  virtual void SetOutputError(size_t unit_index,CTensor<type_t>& error)=0;///<задать ошибку и расчитать дельту
  virtual void ClipWeight(type_t min,type_t max)=0;///<ограничить веса в диапазон
  void TrainingModeGradient(void)///<включить режим обучения "градиентный спуск"
  {
   TrainingMode=TRAINING_MODE_GRADIENT;
  }
  void TrainingModeAdam(void)///<включить режим обучения "алгоритм Adam"
  {
   TrainingMode=TRAINING_MODE_ADAM;
  }
  TRAINING_MODE GetTrainingMode(void)///<получить выбранный режим обучения
  {
   return(TrainingMode);
  }
  //-открытые статические функции-----------------------------------------------------------------------
};

#endif
