#ifndef C_CUDA_DEVICE_VECTOR_CU_H
#define C_CUDA_DEVICE_VECTOR_CU_H

//****************************************************************************************************
//Класс вектора на устройстве в CUDA
//****************************************************************************************************

#include <stdio.h>
#include <stdint.h>

#include <cuda_runtime.h>
#include <cuda_runtime_api.h>

#include "handle_error.cu.h"
#include "../system/system.h"

//****************************************************************************************************
//подключаемые библиотеки
//****************************************************************************************************

//****************************************************************************************************
//макроопределения
//****************************************************************************************************

//****************************************************************************************************
//константы
//****************************************************************************************************

//****************************************************************************************************
//глобальные переменные
//****************************************************************************************************

//****************************************************************************************************
//предварительные объявления
//****************************************************************************************************

//****************************************************************************************************
//Класс разделяемого умного указателя в CUDA
//****************************************************************************************************
template<class type_t>
class CCUDADeviceVector
{
 //-дружественные функции-------------------------------------------------------------------------------
 public:
  //-перечисления---------------------------------------------------------------------------------------
  //-структуры------------------------------------------------------------------------------------------
  //-константы------------------------------------------------------------------------------------------
 private:
  //-переменные-----------------------------------------------------------------------------------------
  size_t Size;///<размер данных в элементах
  type_t *ItemPtr;///<указатель на данные
  public:
  //-конструктор----------------------------------------------------------------------------------------
  __host__ CCUDADeviceVector(size_t size=0);
  //-конструктор копирования----------------------------------------------------------------------------
  __host__ CCUDADeviceVector(const CCUDADeviceVector<type_t> &cCUDADeviceVector);
  //-деструктор-----------------------------------------------------------------------------------------
  __host__ ~CCUDADeviceVector();
 public:
  //-открытые функции-----------------------------------------------------------------------------------
  __host__ void clear(void);///<удалить данные
  __host__ void resize(size_t size);///<изменить размер данных
  __host__ void swap(CCUDADeviceVector<type_t> &cCUDADeviceVector);///<обменять местами
  __host__ void move(CCUDADeviceVector<type_t> &cCUDADeviceVector);///<переместить
  __device__ __host__ size_t size(void);///<получить количество элементов
  __device__ __host__ type_t* get(void) const;///<получить указатель
  __host__ CCUDADeviceVector<type_t>& operator=(const CCUDADeviceVector<type_t> &cCUDADeviceVector);///<оператор "="
  __host__ void copy_host_to_device(const type_t *item_ptr,size_t items) const;///<скопировать на устройство
  __host__ void copy_device_to_host(type_t *item_ptr,size_t items) const;///<скопировать с устройства
 private:
  //-закрытые функции-----------------------------------------------------------------------------------
};
//****************************************************************************************************
//конструктор и деструктор класса
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
//конструктор
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ CCUDADeviceVector<type_t>::CCUDADeviceVector(size_t size)
{
 Size=0;
 ItemPtr=NULL;
 resize(size);
}

//----------------------------------------------------------------------------------------------------
//конструктор копирования
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ CCUDADeviceVector<type_t>::CCUDADeviceVector(const CCUDADeviceVector<type_t> &cCUDADeviceVector)
{
 if (&cCUDADeviceVector==this) return;
 resize(cCUDADeviceVector.Size);
 if (Size>0)
 {
  HANDLE_ERROR(cudaMemcpy(ItemPtr,cCUDADeviceVector.ItemPtr,sizeof(type_t)*Size,cudaMemcpyDeviceToDevice));
 }
}
//----------------------------------------------------------------------------------------------------
//деструктор
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ CCUDADeviceVector<type_t>::~CCUDADeviceVector()
{
 clear();
}
//****************************************************************************************************
//закрытые функции
//****************************************************************************************************


//****************************************************************************************************
//открытые функции класса
//****************************************************************************************************

//----------------------------------------------------------------------------------------------------
///!удалить данные
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ void CCUDADeviceVector<type_t>::clear(void)
{
 if (ItemPtr!=NULL)
 {
  HANDLE_ERROR(cudaFree(ItemPtr));
 }
 ItemPtr=NULL;
 Size=0;
}
//----------------------------------------------------------------------------------------------------
///!изменить размер данных
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ void CCUDADeviceVector<type_t>::resize(size_t size)
{
 if (size==Size) return;
 clear();
 Size=size;
 if (size>0)
 {
  HANDLE_ERROR(cudaMalloc((void**)&ItemPtr,sizeof(type_t)*size));
 }
}

//----------------------------------------------------------------------------------------------------
///!получить указатель
//----------------------------------------------------------------------------------------------------
template<class type_t>
__device__ __host__ type_t* CCUDADeviceVector<type_t>::get(void) const
{
 return(ItemPtr);
}

//----------------------------------------------------------------------------------------------------
///!оператор "="
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ CCUDADeviceVector<type_t>& CCUDADeviceVector<type_t>::operator=(const CCUDADeviceVector<type_t> &cCUDADeviceVector)
{
 if (this!=&cCUDADeviceVector)
 {
  resize(cCUDADeviceVector.Size);
  if (Size>0)
  {
   HANDLE_ERROR(cudaMemcpy(ItemPtr,cCUDADeviceVector.ItemPtr,sizeof(type_t)*Size,cudaMemcpyDeviceToDevice));
  }
 }
 return(*this);
}
//----------------------------------------------------------------------------------------------------
///<обменять местами
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ void CCUDADeviceVector<type_t>::swap(CCUDADeviceVector<type_t> &cCUDADeviceVector)
{
 size_t size=cCUDADeviceVector.Size;
 type_t *ptr=cCUDADeviceVector.ItemPtr;
 cCUDADeviceVector.Size=Size;
 cCUDADeviceVector.ItemPtr=ItemPtr;
 Size=size;
 ItemPtr=ptr;
}
//----------------------------------------------------------------------------------------------------
///<переместить
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ void CCUDADeviceVector<type_t>::move(CCUDADeviceVector<type_t> &cCUDADeviceVector)
{
 clear();
 Size=cCUDADeviceVector.Size;
 ItemPtr=cCUDADeviceVector.ItemPtr;
 cCUDADeviceVector.Size=0;
 cCUDADeviceVector.ItemPtr=NULL;
}
//----------------------------------------------------------------------------------------------------
///!получить количество элементов
//----------------------------------------------------------------------------------------------------
template<class type_t>
__device__ __host__ size_t CCUDADeviceVector<type_t>::size(void)
{
 return(Size);
}

//----------------------------------------------------------------------------------------------------
///!скопировать на устройство
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ void CCUDADeviceVector<type_t>::copy_host_to_device(const type_t *item_ptr,size_t items) const
{
 if (items>Size) throw("CCUDADeviceVector<type_t>::copy_host_to_device: копируемое количество элементов превышает размер выделенной памяти!");
 if (items>0)
 {
  HANDLE_ERROR(cudaMemcpy(ItemPtr,const_cast<type_t*>(item_ptr),sizeof(type_t)*items,cudaMemcpyHostToDevice));
 }
}
//----------------------------------------------------------------------------------------------------
///!скопировать с устройства
//----------------------------------------------------------------------------------------------------
template<class type_t>
__host__ void CCUDADeviceVector<type_t>::copy_device_to_host(type_t *item_ptr,size_t items) const
{
 if (items>Size) throw("CCUDADeviceVector<type_t>::copy_device_to_host: копируемое количество элементов превышает размер выделенной памяти!");
 if (items>0)
 {
  HANDLE_ERROR(cudaMemcpy(item_ptr,ItemPtr,sizeof(type_t)*items,cudaMemcpyDeviceToHost));
 }
}

#endif
